<!DOCTYPE html>
<html>

<body>

<canvas id="canvas" width="400" height="300" style="border:1px solid#000000;">
Your browser does not support the HTML canvas tag.
</canvas>
<script>


// Simple vector in 3D with numbers for x, y and z
class Vec3 {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Add other vector to this one and return the result
    add(other) {
        return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);
    }

    // Subtract other vector from this one and return the result
    minus(other) {
        return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);
    }

    // Multiply other vector by this one and return the result
    multiply(other) {
        return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);
    }

    // Scale this vector by the number scalar and return the result
    scale(scalar) {
        return new Vec3(this.x * scalar, this.y * scalar, this.z * scalar);
    }
    
    // Calculate the dot product of this vector with the other and return the result
    dot(other) {
        return (this.x * other.x) + (this.y * other.y) + (this.z * other.z);
    }

    cross(other) {
        return new Vec3(this.y * other.z - this.z * other.y, this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);
    }

    // Calculate and return the magnitude of this vector
    magnitude() {
        return Math.sqrt(this.magnitudeSquared());
    }
    
    // Calculate and return the magnitude of this vector without the square root
    magnitudeSquared() {
        return (this.x * this.x) + (this.y * this.y) + (this.z * this.z);
    }

    // Return a normalised version of this vector
    normalised() {
        return this.scale(1 / this.magnitude());
    }

    inverse() {
        return new Vec3(1 / this.x, 1 / this.y, 1 / this.z)
    }

    min(other) {
        return new Vec3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));
    }

    max(other) {
        return new Vec3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));
    }

    static lerp(a, b, t) {
        return a.scale(1-t).add(b.scale(t));
    }
}

// A sphere in 3D space. Has centre, radius and colour all of which are Vec3s
class Sphere {
    constructor(centre, radius, material) {
        this.centre = centre;
        this.radius = radius;
        this.material = material;
    }

    // Calculate the point on the sphere  where the ray intersects using 
    // a quadratic equation and return the t value of the ray for that point
    // If two solutions exist return the minus solution
    // If no solutions exist return -1
    rayIntersects(ray) {
        let rayOrigin = ray.origin.minus(this.centre);
        let a = ray.direction.dot(ray.direction);
        let b = 2 * rayOrigin.dot(ray.direction);
        let c = rayOrigin.dot(rayOrigin) - this.radius * this.radius;
        let discriminant = b * b - 4 * a * c;

        if (discriminant >= 0) {
            let t = (-b - Math.sqrt(discriminant)) / (2 * a);
            let intersectionPoint = ray.pointAt(t);
            let intersectionNormal = intersectionPoint.minus(this.centre).normalised();
            return new RayCastResult(intersectionPoint, intersectionNormal, t, this.material);
        } else {
            return miss();
        }
    }
}

class Triangle {
    constructor(posA, posB, posC, normalA, normalB, normalC) {
        this.posA = posA;
        this.posB = posB;
        this.posC = posC;
        this.normalA = normalA;
        this.normalB = normalB;
        this.normalC = normalC;
    }

    rayIntersects(ray) {
        const epsilon = 0.0000001;

        let edge1 = this.posB.minus(this.posA);
        let edge2 = this.posC.minus(this.posA);
        let rayCrossEdge2 = ray.direction.cross(edge2);
        let determinant = edge1.dot(rayCrossEdge2);

        if (determinant > -epsilon && determinant < epsilon) {
            return miss();
        }

        let invDet = 1 / determinant;
        let s = ray.origin.minus(this.posA);
        let u = invDet * s.dot(rayCrossEdge2);

        if (u < 0 || u > 1) {
            return miss();
        }

        let sCrossEdge1 = s.cross(edge1);
        let v = invDet * ray.direction.dot(sCrossEdge1);
        let w = 1 - u - v; 

        if (v < 0 || u + v > 1) {
            return miss();
        }

        let t = invDet * edge2.dot(sCrossEdge1);

        if (t > epsilon) {
            let normal = this.normalB.scale(u).add(this.normalC.scale(v)).add(this.normalA.scale(w)).normalised();
            return new RayCastResult(ray.pointAt(t), normal, t);
        } else {
            return miss();
        }      
    }
}

class Mesh {
    constructor(firstTriangleIndex, numTriangles, bounds, material) {
        this.firstTriangleIndex = firstTriangleIndex;
        this.numTriangles = numTriangles;
        this.aabb = new AABB(bounds);
        this.material = material;
    }
}

class AABB {
    constructor(bounds) {
        this.bounds = bounds;
    }

    rayIntersects(ray) {
        let tMin = this.bounds[0].minus(ray.origin).multiply(ray.invDir);
        let tMax = this.bounds[1].minus(ray.origin).multiply(ray.invDir);

        let t1 = tMin.min(tMax);
        let t2 = tMin.max(tMax);

        let tNear = Math.max(Math.max(t1.x, t1.y), t1.z);
        let tFar = Math.max(Math.max(t2.x, t2.y), t2.z);

        return tNear <= tFar;
    }
}

// Ray which has an origin and direction, both are Vec3s
class Ray {
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction;
        this.invDir = direction.inverse();
    }

    // Calculate and return the point in space (a Vec3) for this ray for the given value of t
    pointAt(t) {
        return this.origin.add(this.direction.scale(t));
    }
}

// The result of casting a ray into our scene
// Position is the point where the ray intersects a sphere in the scene
// Normal is the normal unit vector of the sphere at the intersection point
// t is the t value along the ray where the intersection point is.  This value should, be -1 when the ray hits nothing
// SphereIndex is the array index of the sphere hit by the ray
class RayCastResult {
    constructor(position, normal, t, material = new Material(new Vec3(1, 1, 1))) {
        this.position = position;
        this.normal = normal;
        this.t = t;
        this.material = material;
    }
}

class Material {
    constructor(colour, smoothness = 0, specularProbability = 0, specularColour = new Vec3(1, 1, 1), emissionColour = new Vec3(0, 0, 0), emissionStrength = 0) {
        this.colour = colour;
        this.smoothness = smoothness;
        this.specularProbability = specularProbability;
        this.specularColour = specularColour;
        this.emissionColour = emissionColour;
        this.emissionStrength = emissionStrength;
    }
}

// Return a RayCastResult when a ray misses everything in the scene
function miss() {
    return new RayCastResult(new Vec3(0,0,0), new Vec3(0,0,0), -1, -1);
}

// Check whether a ray hits anything in the scene and return a RayCast Result
function traceRay(ray) {
    let closestHit = miss();
    t = Infinity;

    for (let i = 0; i < spheres.length; i++) {
        let raycastResult = spheres[i].rayIntersects(ray);
        if (raycastResult.t > 0 && raycastResult.t < t) {
            t = raycastResult.t;
            closestHit = raycastResult;
        }
    }

    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        if (!meshes[meshIndex].aabb.rayIntersects(ray)) {
            continue;
        }

        for (let i = 0; i < meshes[meshIndex].numTriangles; i++) {
            let triIndex = meshes[meshIndex].firstTriangleIndex + i;
            let raycastResult = triangles[triIndex].rayIntersects(ray);
            if (raycastResult.t > 0 && raycastResult.t < t) {
                t = raycastResult.t;
                closestHit = raycastResult;
                closestHit.material = meshes[meshIndex].material;
            }   
        }   
    }

    return closestHit;
}

function smoothstep(edge0, edge1, x) {
    x = clamp((x - edge0) / (edge1 - edge0));

    return x * x * (3 - 2 * x);
}

function clamp(x, lowerLimit = 0, upperLimit = 1) {
    if (x < lowerLimit) return lowerLimit;
    if (x > upperLimit) return upperLimit;
    return x;
}

function getEnvironmentLight(ray) {
    const skyColourHorizon = new Vec3(0.1, 0.1, 0.3);
    const skyColourZenith = new Vec3(0.05, 0.1, 0.2);
    const groundColour = new Vec3(0, 0, 0);

    let skyGradientT = Math.pow(smoothstep(0, 0.4, ray.direction.y), 0.35);
    let skyGradient = skyColourHorizon.scale(1-skyGradientT).add(skyColourZenith.scale(skyGradientT));
    let sun = Math.pow(Math.max(0, ray.direction.dot(negLightDirection)), sunFocus) * lightIntensity;

    let groundToSkyT = smoothstep(-0.15, 0, ray.direction.y);
    let sunMask = groundToSkyT >= 1 ? 1 : 0;
    let lerped = groundColour.scale(1-groundToSkyT).add(skyGradient.scale(groundToSkyT));
    return lerped.add(new Vec3(sun, sun, sun).scale(sunMask));
}

function randomValueNormalDistribution() {
    let theta = 2 * Math.PI * Math.random();
    let rho = Math.sqrt(-2 * Math.log(1 - Math.random()));
    return rho * Math.cos(theta);
}

function randomDirection() {
    let x = randomValueNormalDistribution();
    let y = randomValueNormalDistribution();
    let z = randomValueNormalDistribution();
    return new Vec3(x, y, z).normalised();
}

function randomPointInCircle() {
    let angle = Math.random() * 2 * Math.PI;
    let pointOnCircle = new Vec3(Math.cos(angle), Math.sin(angle), 0);
    return pointOnCircle.scale(Math.sqrt(Math.random()));
}

// Returns the colour the ray should have as a Vec3 with RGB values in [0,1]
const maxBounceCount = 3;
function rayColour(ray) {
    let incomingLight = new Vec3(0, 0, 0);
    let rayColour = new Vec3(1, 1, 1);

    for (let i = 0; i < maxBounceCount; i++) {
        let castResult = traceRay(ray);
        let material = castResult.material;

        if (castResult.t >= 0) {
            let isSpecularBounce = material.specularProbability >= Math.random() ? 1 : 0;

            ray.origin = castResult.position;
            let diffuseDirection = castResult.normal.add(randomDirection()).normalised();
            let specularDirection = ray.direction.minus(castResult.normal.scale(2).scale(castResult.normal.dot(ray.direction))).normalised();
            ray.direction = Vec3.lerp(diffuseDirection, specularDirection, material.smoothness * isSpecularBounce).normalised();
            
            let emittedLight = material.emissionColour.scale(material.emissionStrength);
            incomingLight = incomingLight.add(emittedLight.multiply(rayColour));
            rayColour = rayColour.multiply(Vec3.lerp(material.colour, material.specularColour, isSpecularBounce));
        } else {
            incomingLight = incomingLight.add(getEnvironmentLight(ray).multiply(rayColour));
            break;
        }
    }

    return incomingLight;
}

// Sets a pixel at (x, y) in the canvas with an RGB Vec3
function setPixel(x, y, colour) {
    var c = document.getElementById("canvas");
    var ctx = c.getContext("2d");
    ctx.fillStyle = "rgba("+colour.x+","+colour.y+","+colour.z+","+1+")";
    ctx.fillRect(x, c.height - y, 1, 1);
}

function calculateMeshBounds(verts) {
    let boundsMin = new Vec3(Infinity, Infinity, Infinity);
    let boundsMax = new Vec3(-Infinity, -Infinity, -Infinity);
    
    for (let i = 0; i < verts.length; i++) {
        if (verts[i].x >= boundsMax.x) {
            boundsMax.x = verts[i].x;
        }
        if (verts[i].y >= boundsMax.y) {
            boundsMax.y = verts[i].y;
        }
        if (verts[i].z >= boundsMax.z) {
            boundsMax.z = verts[i].z;
        }
        
        if (verts[i].x < boundsMin.x) {
            boundsMin.x = verts[i].x;
        }
        if (verts[i].y < boundsMin.y) {
            boundsMin.y = verts[i].y;
        }
        if (verts[i].z < boundsMin.z) {
            boundsMin.z = verts[i].z;
        }
    }
    return [boundsMin, boundsMax];
}

async function meshFromOBJ(objPath, colour) {
    const objFile = await fetch(objPath); 
    const text = await objFile.text();

    let lines = text.split("\n");

    let verts = []
    let normals = []
    let tris = []

    for (line of lines) {
        let chunks = line.split(" ");
        if (chunks[0] === "v") {
            verts.push(new Vec3(parseFloat(chunks[1]), parseFloat(chunks[2]), parseFloat(chunks[3])))
        }
        if (chunks[0] === "vn") {
            normals.push(new Vec3(parseFloat(chunks[1]), parseFloat(chunks[2]), parseFloat(chunks[3])))
        }
        if (chunks[0] === "f") {
            let vert1Index = chunks[1].split("//")[0] - 1;
            let vert2Index = chunks[2].split("//")[0] - 1;
            let vert3Index = chunks[3].split("//")[0] - 1;
            let normal1Index = chunks[1].split("//")[1] - 1;
            let normal2Index = chunks[2].split("//")[1] - 1;
            let normal3Index = chunks[3].split("//")[1] - 1;
            tris.push(
                new Triangle(
                    verts[vert1Index], verts[vert2Index], verts[vert3Index], 
                    normals[normal1Index], normals[normal2Index], normals[normal3Index]
                )
            );
        }
    }

    let bounds = calculateMeshBounds(verts);
    let mesh = new Mesh(triangles.length, tris.length, bounds, colour)
    triangles.push(...tris);
    return mesh;
}

const spheres = [
    // new Sphere(new Vec3(-0.5,-0.2,-1), 0.2, new Material(new Vec3(0,0,0), new Vec3(0, 1, 0), 2)),       // Light sphere
    // new Sphere(new Vec3(0.2,-0.2,-2), 0.3, new Material(new Vec3(1,0,0), 1, 0.02)),       // Red sphere
    // new Sphere(new Vec3(0.25,-0.35,-1.25), 0.15, new Material(new Vec3(1,1,1), 0, 0, new Vec3(1, 1, 1), new Vec3(1, 1, 1), 10)),  // Blue sphere 
    // new Sphere(new Vec3(-0.3,-0.35,-1.8), 0.1, new Material(new Vec3(1,1,0), 0, 0, new Vec3(1, 1, 1), new Vec3(1, 1, 0), 30)),  // Blue sphere 
    //new Sphere(new Vec3(0,-100.5,-1), 100, new Material(new Vec3(.7,.1,.7))),   // Big sphere
    // new Sphere(new Vec3(-0.4,-0.2,-3), 0.3, new Material(new Vec3(0,1,0), 1, 0.02)),
    // new Sphere(new Vec3(-1, 0.2,-5.1), 0.6, new Material(new Vec3(0,1,1), 1, 0.02)),
];

const triangles = [];

const meshes = [];

let lightDirection  = new Vec3(-0.2, -0.2, 1).normalised();
// let lightDirection  = new Vec3(-2.5, -0.6, -1).normalised();
let negLightDirection = new Vec3(-lightDirection.x, -lightDirection.y, -lightDirection.z);
let lightIntensity = 1;
let sunFocus = 800;


const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const offscreenCanvas = new OffscreenCanvas(canvas.width, canvas.height);
const offscreenCtx = offscreenCanvas.getContext("2d", {
    willReadFrequently: true,
});

let imageWidth = canvas.width;
let imageHeight = canvas.height;
let aspectRatio = imageHeight / imageWidth;

let viewportWidth = 2;
let viewportHeight = viewportWidth * aspectRatio;
let focalLength = 2;

let camPosition = new Vec3(0, 0, 0);
let camForward = new Vec3(0, 0, -1);
let camUp = new Vec3(0, 1, 0);
let camRight = new Vec3(1, 0, 0);
let horizontal = new Vec3(viewportWidth, 0, 0);
let vertical = new Vec3(0, viewportHeight, 0);
let lowerLeftCorner = camPosition.minus(horizontal.scale(0.5)).minus(vertical.scale(0.5)).minus(new Vec3(0, 0, focalLength));

let colour = new Vec3(0,0,0);

let numRaysPerPixel = 5;

let divergeStrength = 1;
let defocusStrength = 1;
let focusDistance = 1;

let lastFrameImageData = ctx.getImageData(0, 0, imageWidth, imageHeight);
let numFramesRendered = 0;
async function main() {
    meshes.push(await meshFromOBJ("scene_objects/light_left.obj", new Material(new Vec3(0, 0, 0), 0, 0, new Vec3(0, 0, 0), new Vec3(1, 1, 1), 3.5)));
    meshes.push(await meshFromOBJ("scene_objects/light_right.obj", new Material(new Vec3(0, 0, 0), 0, 0, new Vec3(0, 0, 0), new Vec3(1, 1, 1), 3.5)));
    meshes.push(await meshFromOBJ("scene_objects/grass.obj", new Material(new Vec3(0.108, 0.576, 0.060))));
    meshes.push(await meshFromOBJ("scene_objects/river.obj", new Material(new Vec3(0.155, 0.534, 0.793))));
    meshes.push(await meshFromOBJ("scene_objects/mountain.obj", new Material(new Vec3(0.145, 0.145, 0.145))));
    meshes.push(await meshFromOBJ("scene_objects/tree1.obj", new Material(new Vec3(0.145, 0.048, 0.010))));
    meshes.push(await meshFromOBJ("scene_objects/tree2.obj", new Material(new Vec3(0.145, 0.048, 0.010))));
    meshes.push(await meshFromOBJ("scene_objects/tree3.obj", new Material(new Vec3(0.145, 0.048, 0.010))));
    meshes.push(await meshFromOBJ("scene_objects/leaves1.obj", new Material(new Vec3(0.108, 0.576, 0.060))));
    meshes.push(await meshFromOBJ("scene_objects/leaves2.obj", new Material(new Vec3(0.108, 0.576, 0.060))));
    meshes.push(await meshFromOBJ("scene_objects/leaves3.obj", new Material(new Vec3(0.995, 0.170, 0))));
    meshes.push(await meshFromOBJ("scene_objects/cloud1.obj", new Material(new Vec3(1, 1, 1))));
    meshes.push(await meshFromOBJ("scene_objects/cloud2.obj", new Material(new Vec3(1, 1, 1))));
    meshes.push(await meshFromOBJ("scene_objects/cloud3.obj", new Material(new Vec3(1, 1, 1))));
    meshes.push(await meshFromOBJ("scene_objects/cloud4.obj", new Material(new Vec3(1, 1, 1))));
    meshes.push(await meshFromOBJ("scene_objects/cloud5.obj", new Material(new Vec3(1, 1, 1))));
    meshes.push(await meshFromOBJ("scene_objects/cloud6.obj", new Material(new Vec3(1, 1, 1))));
    meshes.push(await meshFromOBJ("scene_objects/cloud5.obj", new Material(new Vec3(1, 1, 1))));

    for (let i = 0; i < imageWidth; i++)
    {
        for (let j = 0; j <= imageHeight; j++)
        {
            for (let n = 0; n < numRaysPerPixel; n++) {
                let u = i / (imageWidth-1);
                let v = j / (imageHeight-1);
                
                let defocusJitter = randomPointInCircle().scale(defocusStrength / imageWidth);
                let rayOrigin = camPosition.add(camRight.scale(defocusJitter.x)).add(camUp.scale(defocusJitter.y)); 
                let ray = new Ray(rayOrigin, lowerLeftCorner.add(horizontal.scale(u)).add(vertical.scale(v)).minus(camPosition).normalised());

                //let focusPoint = ray.pointAt(focusDistance);
                let focusPoint = lowerLeftCorner.add(horizontal.scale(u)).add(vertical.scale(v)).add(new Vec3(0, 0, -focusDistance));
                ray.direction = focusPoint.minus(ray.origin).normalised();
                colour = colour.add(rayColour(ray).scale(255));
            }
            colour = colour.scale(1/numRaysPerPixel);
            setPixel(i,j,colour);
        }
    }

    let weight = 1 / (numFramesRendered + 1);

    offscreenCtx.drawImage(canvas, 0, 0, imageWidth, imageHeight, 0, 0, imageWidth, imageHeight);

    let imageData = offscreenCtx.getImageData(0, 0, imageWidth, imageHeight);
    for (let pixelIndex = 0; pixelIndex < imageData.data.length; pixelIndex += 4) {
        let r = lastFrameImageData.data[pixelIndex] * (1 - weight) + imageData.data[pixelIndex] * weight;
        let g = lastFrameImageData.data[pixelIndex+1] * (1 - weight) + imageData.data[pixelIndex+1] * weight;
        let b = lastFrameImageData.data[pixelIndex+2] * (1 - weight) + imageData.data[pixelIndex+2] * weight;
        imageData.data[pixelIndex] = r;
        imageData.data[pixelIndex+1] = g;
        imageData.data[pixelIndex+2] = b;
    }
    offscreenCtx.putImageData(imageData, 0, 0);
    lastFrameImageData = offscreenCtx.getImageData(0, 0, imageWidth, imageHeight);
    ctx.drawImage(offscreenCanvas, 0, 0, imageWidth, imageHeight, 0, 0, imageWidth, imageHeight);

    numFramesRendered++;
    requestAnimationFrame(main);
}

main();

</script>

</body>
</html>
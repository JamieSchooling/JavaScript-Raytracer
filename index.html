<!DOCTYPE html>
<html>

<body>

<canvas id="canvas" width="400" height="300" style="border:1px solid#000000;">
Your browser does not support the HTML canvas tag.
</canvas>

<script>


// Simple vector in 3D with numbers for x, y and z
class Vec3 {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Add other vector to this one and return the result
    add(other) {
        return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);
    }

    // Subtract other vector from this one and return the result
    minus(other) {
        return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);
    }

    // Multiply other vector by this one and return the result
    multiply(other) {
        return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);
    }

    // Scale this vector by the number scalar and return the result
    scale(scalar) {
        return new Vec3(this.x * scalar, this.y * scalar, this.z * scalar);
    }
    
    // Calculate the dot product of this vector with the other and return the result
    dot(other) {
        return (this.x * other.x) + (this.y * other.y) + (this.z * other.z);
    }

    cross(other) {
        return new Vec3(this.y * other.z - this.z * other.y, this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);
    }

    // Calculate and return the magnitude of this vector
    magnitude() {
        return Math.sqrt(this.magnitudeSquared());
    }
    
    // Calculate and return the magnitude of this vector without the square root
    magnitudeSquared() {
        return (this.x * this.x) + (this.y * this.y) + (this.z * this.z);
    }

    // Return a normalised version of this vector
    normalised() {
        return this.scale(1 / this.magnitude());
    }

    inverse() {
        return new Vec3(1 / this.x, 1 / this.y, 1 / this.z)
    }

    min(other) {
        return new Vec3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));
    }

    max(other) {
        return new Vec3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));
    }
}

// A sphere in 3D space. Has centre, radius and colour all of which are Vec3s
class Sphere {
    constructor(centre, radius, colour) {
        this.centre = centre;
        this.radius = radius;
        this.colour = colour;
    }

    // Calculate the point on the sphere  where the ray intersects using 
    // a quadratic equation and return the t value of the ray for that point
    // If two solutions exist return the minus solution
    // If no solutions exist return -1
    rayIntersects(ray) {
        let rayOrigin = ray.origin.minus(this.centre);
        let a = ray.direction.dot(ray.direction);
        let b = 2 * rayOrigin.dot(ray.direction);
        let c = rayOrigin.dot(rayOrigin) - this.radius * this.radius;
        let discriminant = b * b - 4 * a * c;

        if (discriminant >= 0) {
            let t = (-b - Math.sqrt(discriminant)) / (2 * a);
            let intersectionPoint = ray.pointAt(t);
            let intersectionNormal = intersectionPoint.minus(this.centre).normalised();
            return new RayCastResult(intersectionPoint, intersectionNormal, t, this.colour);
        } else {
            return miss();
        }
    }
}

class Triangle {
    constructor(posA, posB, posC, normalA, normalB, normalC) {
        this.posA = posA;
        this.posB = posB;
        this.posC = posC;
        this.normalA = normalA;
        this.normalB = normalB;
        this.normalC = normalC;
    }

    rayIntersects(ray) {
        const epsilon = 0.0000001;

        let edge1 = this.posB.minus(this.posA);
        let edge2 = this.posC.minus(this.posA);
        let rayCrossEdge2 = ray.direction.cross(edge2);
        let determinant = edge1.dot(rayCrossEdge2);

        if (determinant > -epsilon && determinant < epsilon) {
            return miss();
        }

        let invDet = 1 / determinant;
        let s = ray.origin.minus(this.posA);
        let u = invDet * s.dot(rayCrossEdge2);

        if (u < 0 || u > 1) {
            return miss();
        }

        let sCrossEdge1 = s.cross(edge1);
        let v = invDet * ray.direction.dot(sCrossEdge1);

        if (v < 0 || u + v > 1) {
            return miss();
        }

        let t = invDet * edge2.dot(sCrossEdge1);

        if (t > epsilon) {
            return new RayCastResult(ray.pointAt(t), edge1.cross(edge2).normalised(), t);
        } else {
            return miss();
        }      
    }
}

class Mesh {
    constructor(firstTriangleIndex, numTriangles, bounds, colour) {
        this.firstTriangleIndex = firstTriangleIndex;
        this.numTriangles = numTriangles;
        this.aabb = new AABB(bounds);
        this.colour = colour;
    }
}

class AABB {
    constructor(bounds) {
        this.bounds = bounds;
    }

    rayIntersects(ray) {
        let tMin = this.bounds[0].minus(ray.origin).multiply(ray.invDir);
        let tMax = this.bounds[1].minus(ray.origin).multiply(ray.invDir);

        let t1 = tMin.min(tMax);
        let t2 = tMin.max(tMax);

        let tNear = Math.max(Math.max(t1.x, t1.y), t1.z);
        let tFar = Math.max(Math.max(t2.x, t2.y), t2.z);

        return tNear <= tFar;
    }
}

// Ray which has an origin and direction, both are Vec3s
class Ray {
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction;
        this.invDir = direction.inverse();
    }

    // Calculate and return the point in space (a Vec3) for this ray for the given value of t
    pointAt(t) {
        return this.origin.add(this.direction.scale(t));
    }
}

// The result of casting a ray into our scene
// Position is the point where the ray intersects a sphere in the scene
// Normal is the normal unit vector of the sphere at the intersection point
// t is the t value along the ray where the intersection point is.  This value should, be -1 when the ray hits nothing
// SphereIndex is the array index of the sphere hit by the ray
class RayCastResult {
    constructor(position, normal, t, colour = new Vec3(1, 1, 1)) {
        this.position = position;
        this.normal = normal;
        this.t = t;
        this.colour = colour;
    }
}

// Return a RayCastResult when a ray misses everything in the scene
function miss() {
    return new RayCastResult(new Vec3(0,0,0), new Vec3(0,0,0), -1, -1);
}

// Check whether a ray hits anything in the scene and return a RayCast Result
function traceRay(ray) {
    let closestHit = miss();
    t = Infinity;

    for (let i = 0; i < spheres.length; i++) {
        let raycastResult = spheres[i].rayIntersects(ray);
        if (raycastResult.t > 0 && raycastResult.t < t) {
            t = raycastResult.t;
            closestHit = raycastResult;
        }
    }

    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        if (!meshes[meshIndex].aabb.rayIntersects(ray)) {
            continue;
        }

        for (let i = 0; i < meshes[meshIndex].numTriangles; i++) {
            let triIndex = meshes[meshIndex].firstTriangleIndex + i;
            let raycastResult = triangles[triIndex].rayIntersects(ray);
            if (raycastResult.t > 0 && raycastResult.t < t) {
                t = raycastResult.t;
                closestHit = raycastResult;
                closestHit.colour = meshes[meshIndex].colour;
            }   
        }   
    }

    return closestHit;
}

// Calculate and return the background colour based on the ray
function backgroundColour(ray) {
    let white = new Vec3(1, 1, 1);
    let blue = new Vec3(0.3, 0.5, 0.9);
    t = 0.5 * (ray.direction.y + 1.0);
    return white.scale(1-t).add(blue.scale(t));
}

// Returns the colour the ray should have as a Vec3 with RGB values in [0,1]
function rayColour(ray) {
    let castResult = traceRay(ray);
    if(castResult.t < 0) return backgroundColour(ray);

    let specularPower = 20;
    let specularStrength = 0.8;
    let reflectedDir = lightDirection.minus(castResult.normal.scale(2).scale(castResult.normal.dot(lightDirection))).normalised();
    let viewDir = camPosition.minus(castResult.position).normalised();
    
    let specular = Math.pow(Math.max(viewDir.dot(reflectedDir), 0), specularPower) * specularStrength;
    let diffuse = Math.max(castResult.normal.dot(negLightDirection), 0);
    let ambient = 0.05;

    let albedo = castResult.colour;
    let colour = albedo.scale(ambient + diffuse + specular);

    if (traceRay(new Ray(castResult.position, negLightDirection)).t >= 0) {
        colour = colour.scale(0.4);
    }

    colour.x = Math.sqrt(colour.x);
    colour.y = Math.sqrt(colour.y);
    colour.z = Math.sqrt(colour.z);

    return colour;
}

// Sets a pixel at (x, y) in the canvas with an RGB Vec3
function setPixel(x, y, colour) {
    var c = document.getElementById("canvas");
    var ctx = c.getContext("2d");
    ctx.fillStyle = "rgba("+colour.x+","+colour.y+","+colour.z+","+1+")";
    ctx.fillRect(x, c.height - y, 1, 1);
}

function calculateMeshBounds(verts) {
    let boundsMin = new Vec3(Infinity, Infinity, Infinity);
    let boundsMax = new Vec3(-Infinity, -Infinity, -Infinity);
    
    for (let i = 0; i < verts.length; i++) {
        if (verts[i].x >= boundsMax.x) {
            boundsMax.x = verts[i].x;
        }
        if (verts[i].y >= boundsMax.y) {
            boundsMax.y = verts[i].y;
        }
        if (verts[i].z >= boundsMax.z) {
            boundsMax.z = verts[i].z;
        }
        
        if (verts[i].x < boundsMin.x) {
            boundsMin.x = verts[i].x;
        }
        if (verts[i].y < boundsMin.y) {
            boundsMin.y = verts[i].y;
        }
        if (verts[i].z < boundsMin.z) {
            boundsMin.z = verts[i].z;
        }
    }
    return [boundsMin, boundsMax];
}

async function meshFromOBJ(objPath, colour) {
    const objFile = await fetch(objPath); 
    const text = await objFile.text();

    let lines = text.split("\n");

    let verts = []
    let normals = []
    let tris = []

    for (line of lines) {
        let chunks = line.split(" ");
        if (chunks[0] === "v") {
            verts.push(new Vec3(parseFloat(chunks[1]), parseFloat(chunks[2]), parseFloat(chunks[3])))
        }
        if (chunks[0] === "vn") {
            normals.push(new Vec3(parseFloat(chunks[1]), parseFloat(chunks[2]), parseFloat(chunks[3])))
        }
        if (chunks[0] === "f") {
            let vert1Index = chunks[1].split("//")[0] - 1;
            let vert2Index = chunks[2].split("//")[0] - 1;
            let vert3Index = chunks[3].split("//")[0] - 1;
            let normal1Index = chunks[1].split("//")[1] - 1;
            let normal2Index = chunks[2].split("//")[1] - 1;
            let normal3Index = chunks[3].split("//")[1] - 1;
            tris.push(
                new Triangle(
                    verts[vert1Index], verts[vert2Index], verts[vert3Index], 
                    normals[normal1Index], normals[normal2Index], normals[normal3Index]
                )
            );
        }
    }

    let bounds = calculateMeshBounds(verts);
    let mesh = new Mesh(triangles.length, tris.length, bounds, colour)
    triangles.push(...tris);
    return mesh;
}

const spheres = [
    // new Sphere(new Vec3(0,0,-2), 0.3, new Vec3(1,0,0)),       // Red sphere
    // new Sphere(new Vec3(0,0.2,-1.8), 0.15, new Vec3(0,0,1)),  // Blue sphere
    new Sphere(new Vec3(0,-100.5,-1), 100, new Vec3(1,1,1)),   // Big sphere
];

const triangles = [];

const meshes = [];

let lightDirection  = new Vec3(-1.1, -1.3, -1.5).normalised();
let negLightDirection = new Vec3(-lightDirection.x, -lightDirection.y, -lightDirection.z);

let imageWidth = document.getElementById("canvas").width
let imageHeight = document.getElementById("canvas").height
let aspectRatio = document.getElementById("canvas").height / document.getElementById("canvas").width

let viewportWidth = 2;
let viewportHeight = viewportWidth * aspectRatio;
let focalLength = 1.0;

let camPosition = new Vec3(0, 0, 0);
let horizontal = new Vec3(viewportWidth, 0, 0);
let vertical = new Vec3(0, viewportHeight, 0);
let lowerLeftCorner = camPosition.minus(horizontal.scale(0.5)).minus(vertical.scale(0.5)).minus(new Vec3(0, 0, focalLength));

let colour = new Vec3(0,0,0);

async function main() {
    let mesh = await meshFromOBJ("hand.obj", new Vec3(1, 0.5, 0));
    meshes.push(mesh);


    for (let i = 0; i < imageWidth; i++)
    {
        for (let j = 0; j <= imageHeight; j++)
        {        
            let rayCount = 20;
            for (let n = 0; n < rayCount; n++) {
                let u = i / (imageWidth-1 + Math.random());
                let v = j / (imageHeight-1 + Math.random());
                let randomOffeset = new Vec3(Math.random(), Math.random(), Math.random()).scale(0.005);
                let ray = new Ray(camPosition.add(randomOffeset), lowerLeftCorner.add(horizontal.scale(u)).add(vertical.scale(v)).minus(camPosition));
                colour = colour.add(rayColour(ray).scale(255));
            }
            colour = colour.scale(1/rayCount);
            setPixel(i,j,colour);
        }
    }
}

main();

</script>

</body>
</html>